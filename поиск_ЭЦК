' ============================================================
' СКРИПТ АВТОМАТИЗАЦИИ РАЗРАБОТКИ ПД ПО УСТАНОВКЕ АЛАР
' Определение ЭЦК и выбор защищаемого элемента
' ============================================================

' --- Настройки ---
ScenarioTemplatePath = "C:\Users\k.marchuk\Desktop\сценарии\1.scn"
ScenarioFolderPath   = "C:\Users\k.marchuk\Desktop\сценарии"
MaxRepair = 6
MaxRepair_count = 1

' Параметры для определения ЭЦК
Const DELTA_THRESHOLD = 180  ' Порог расхождения углов (градусы)
Const TIME_WINDOW = 0.5      ' Окно анализа (секунды после возмущения)

' --- Инициализация ---
Set spBranch = Rastr.Tables("vetv")
Set spNode   = Rastr.Tables("node")
Set tblGen   = Rastr.Tables("Generator")

Set xl = CreateObject("Excel.Application")
xl.Visible = True
xl.DisplayAlerts = False
Set wb = xl.Workbooks.Add

' Листы для разных типов анализа
Set wsData = wb.Worksheets(1)
wsData.Name = "Данные динамики"
Set wsResult = wb.Worksheets.Add
wsResult.Name = "Результаты устойчивости"
Set wsECQ = wb.Worksheets.Add
wsECQ.Name = "Анализ ЭЦК"
Set wsALAR = wb.Worksheets.Add
wsALAR.Name = "Рекомендации АЛАР"

Dim resultRow: resultRow = 1
Dim ecqRow: ecqRow = 1
Dim alarRow: alarRow = 1

' --- Подготовка шаблона ---
Call PrepareTemplate

' ============================================================
' НОВЫЙ ФУНКЦИОНАЛ: ОПРЕДЕЛЕНИЕ ЭЦК
' ============================================================

' Структура для хранения информации о группах генераторов
Class GeneratorGroup
    Public Generators()
    Public AvgDelta
    Public Count
    
    Public Sub Init()
        ReDim Generators(-1)
        Count = 0
        AvgDelta = 0
    End Sub
    
    Public Sub AddGenerator(genIndex, deltaVal)
        ReDim Preserve Generators(Count)
        Generators(Count) = genIndex
        Count = Count + 1
        AvgDelta = AvgDelta + deltaVal
    End Sub
    
    Public Sub CalculateAverage()
        If Count > 0 Then AvgDelta = AvgDelta / Count
    End Sub
End Class

' Функция кластеризации генераторов по углам
Function ClusterGeneratorsByDelta(deltaValues, timeValues, analysisTime)
    ' deltaValues - массив углов генераторов в момент analysisTime
    ' Возвращает массив групп генераторов
    
    Dim groups()
    ReDim groups(-1)
    Dim groupCount: groupCount = 0
    
    ' Простая кластеризация: если разница углов > DELTA_THRESHOLD, то разные группы
    For i = 0 To UBound(deltaValues)
        placed = False
        
        ' Пробуем добавить в существующую группу
        For g = 0 To UBound(groups)
            If Abs(deltaValues(i) - groups(g).AvgDelta) < DELTA_THRESHOLD / 2 Then
                groups(g).AddGenerator i, deltaValues(i)
                placed = True
                Exit For
            End If
        Next
        
        ' Создаем новую группу
        If Not placed Then
            ReDim Preserve groups(groupCount)
            Set groups(groupCount) = New GeneratorGroup
            groups(groupCount).Init
            groups(groupCount).AddGenerator i, deltaValues(i)
            groupCount = groupCount + 1
        End If
    Next
    
    ' Пересчитываем средние углы для групп
    For g = 0 To UBound(groups)
        groups(g).CalculateAverage
    Next
    
    ClusterGeneratorsByDelta = groups
End Function

' Функция определения ЭЦК по группам генераторов
Function FindECQLocation(groups, scenarioName)
    ' Записываем результаты кластеризации
    wsECQ.Cells(ecqRow, 1).Value = "Сценарий: " & scenarioName
    wsECQ.Cells(ecqRow, 1).Font.Bold = True
    ecqRow = ecqRow + 1
    
    If UBound(groups) < 1 Then
        wsECQ.Cells(ecqRow, 1).Value = "ЭЦК не обнаружен - все генераторы в синхронизме"
        ecqRow = ecqRow + 2
        FindECQLocation = Nothing
        Exit Function
    End If
    
    ' Выводим группы
    wsECQ.Cells(ecqRow, 1).Value = "Группа"
    wsECQ.Cells(ecqRow, 2).Value = "Генераторы"
    wsECQ.Cells(ecqRow, 3).Value = "Средний угол"
    wsECQ.Cells(ecqRow, 4).Value = "Узел генератора"
    ecqRow = ecqRow + 1
    
    Set colGenNode = tblGen.Cols("Node")
    Set colGenName = tblGen.Cols("Name")
    
    For g = 0 To UBound(groups)
        genList = ""
        nodeList = ""
        For i = 0 To groups(g).Count - 1
            genIdx = groups(g).Generators(i)
            If i > 0 Then 
                genList = genList & ", "
                nodeList = nodeList & ", "
            End If
            genList = genList & colGenName.ZS(genIdx)
            nodeList = nodeList & CStr(colGenNode.Z(genIdx))
        Next
        
        wsECQ.Cells(ecqRow, 1).Value = "Группа " & (g + 1)
        wsECQ.Cells(ecqRow, 2).Value = genList
        wsECQ.Cells(ecqRow, 3).Value = Round(groups(g).AvgDelta, 2)
        wsECQ.Cells(ecqRow, 4).Value = nodeList
        ecqRow = ecqRow + 1
    Next
    
    ecqRow = ecqRow + 1
    
    ' Возвращаем информацию о группах для дальнейшего анализа
    Set FindECQLocation = groups
End Function

' Функция поиска связей между группами генераторов
Function FindCutSetBetweenGroups(group1, group2)
    ' Возвращает список ветвей, которые связывают две группы генераторов
    
    Set cutSet = CreateObject("Scripting.Dictionary")
    
    ' Получаем узлы каждой группы
    Set nodes1 = CreateObject("Scripting.Dictionary")
    Set nodes2 = CreateObject("Scripting.Dictionary")
    
    Set colGenNode = tblGen.Cols("Node")
    
    For i = 0 To group1.Count - 1
        nodeNum = colGenNode.Z(group1.Generators(i))
        nodes1(nodeNum) = True
    Next
    
    For i = 0 To group2.Count - 1
        nodeNum = colGenNode.Z(group2.Generators(i))
        nodes2(nodeNum) = True
    Next
    
    ' Расширяем зоны влияния (ищем связанные узлы)
    ' Упрощенная версия: берем все ветви, где один конец в nodes1, другой в nodes2
    
    Set colIp = spBranch.Cols("ip")
    Set colIq = spBranch.Cols("iq")
    Set colNm = spBranch.Cols("name")
    Set colSta = spBranch.Cols("sta")
    
    For i = 0 To spBranch.Size - 1
        If colSta.Z(i) = 0 Then ' Только включенные ветви
            ip = colIp.Z(i)
            iq = colIq.Z(i)
            
            ' Проверяем, связывает ли ветвь две группы
            If (nodes1.Exists(ip) And nodes2.Exists(iq)) Or _
               (nodes2.Exists(ip) And nodes1.Exists(iq)) Then
                cutSet(i) = colNm.ZS(i)
            End If
        End If
    Next
    
    Set FindCutSetBetweenGroups = cutSet
End Function

' Функция ранжирования ветвей для АЛАР
Function RankBranchesForALAR(cutSet, groups)
    ' Ранжирует ветви по приоритету для установки АЛАР
    ' Критерии:
    ' 1. Малая загрузка (меньше потерь при отключении)
    ' 2. Высокое напряжение (обычно межсистемные связи)
    ' 3. Большое электрическое расстояние (слабая связь)
    
    Set ranked = CreateObject("Scripting.Dictionary")
    
    Set colIe = spBranch.Cols("ie")      ' Ток
    Set colIpr = spBranch.Cols("i_dop_r") ' Допустимый ток
    Set colX = spBranch.Cols("x")         ' Реактивное сопротивление
    Set colUnom = spBranch.Cols("uhom")   ' Номинальное напряжение
    Set colNm = spBranch.Cols("name")
    Set colIp = spBranch.Cols("ip")
    Set colIq = spBranch.Cols("iq")
    
    alarRow = alarRow + 1
    wsALAR.Cells(alarRow, 1).Value = "Рейтинг ветвей для АЛАР"
    wsALAR.Cells(alarRow, 1).Font.Bold = True
    alarRow = alarRow + 1
    
    wsALAR.Cells(alarRow, 1).Value = "Ранг"
    wsALAR.Cells(alarRow, 2).Value = "Название ветви"
    wsALAR.Cells(alarRow, 3).Value = "ip-iq"
    wsALAR.Cells(alarRow, 4).Value = "Загрузка %"
    wsALAR.Cells(alarRow, 5).Value = "U ном, кВ"
    wsALAR.Cells(alarRow, 6).Value = "X, Ом"
    wsALAR.Cells(alarRow, 7).Value = "Приоритет"
    alarRow = alarRow + 1
    
    ' Вычисляем оценки для каждой ветви
    Dim scores()
    ReDim scores(cutSet.Count - 1, 1) ' (индекс ветви, оценка)
    
    idx = 0
    For Each branchIdx In cutSet.Keys
        loading = 0
        If colIpr.Z(branchIdx) > 0 Then
            loading = (colIe.Z(branchIdx) / colIpr.Z(branchIdx)) * 100
        End If
        
        unom = colUnom.Z(branchIdx)
        x = colX.Z(branchIdx)
        
        ' Формула оценки (чем больше, тем лучше для АЛАР):
        ' Высокий приоритет: низкая загрузка + высокое напряжение + большое X
        score = (100 - loading) + (unom / 10) + (x * 100)
        
        scores(idx, 0) = branchIdx
        scores(idx, 1) = score
        idx = idx + 1
    Next
    
    ' Сортируем по убыванию оценки (простая пузырьковая сортировка)
    For i = 0 To UBound(scores, 1) - 1
        For j = i + 1 To UBound(scores, 1)
            If scores(j, 1) > scores(i, 1) Then
                ' Swap
                tmp0 = scores(i, 0)
                tmp1 = scores(i, 1)
                scores(i, 0) = scores(j, 0)
                scores(i, 1) = scores(j, 1)
                scores(j, 0) = tmp0
                scores(j, 1) = tmp1
            End If
        Next
    Next
    
    ' Выводим отсортированный список
    For i = 0 To UBound(scores, 1)
        branchIdx = scores(i, 0)
        
        loading = 0
        If colIpr.Z(branchIdx) > 0 Then
            loading = Round((colIe.Z(branchIdx) / colIpr.Z(branchIdx)) * 100, 1)
        End If
        
        wsALAR.Cells(alarRow, 1).Value = i + 1
        wsALAR.Cells(alarRow, 2).Value = colNm.ZS(branchIdx)
        wsALAR.Cells(alarRow, 3).Value = colIp.Z(branchIdx) & "-" & colIq.Z(branchIdx)
        wsALAR.Cells(alarRow, 4).Value = loading
        wsALAR.Cells(alarRow, 5).Value = colUnom.Z(branchIdx)
        wsALAR.Cells(alarRow, 6).Value = Round(colX.Z(branchIdx), 4)
        wsALAR.Cells(alarRow, 7).Value = Round(scores(i, 1), 2)
        
        ' Выделяем топ-3
        If i < 3 Then
            wsALAR.Cells(alarRow, 2).Interior.ColorIndex = 6 ' Желтый
        End If
        
        alarRow = alarRow + 1
    Next
    
    alarRow = alarRow + 1
    
    Set RankBranchesForALAR = scores
End Function

' ============================================================
' МОДИФИЦИРОВАННАЯ ФУНКЦИЯ РАСЧЕТА ДИНАМИКИ С АНАЛИЗОМ ЭЦК
' ============================================================

Sub RunDynamicsAndAnalyzeECQ(description, scenarioName)
    wsResult.Cells(resultRow, 1).Value = description
    wsResult.Cells(resultRow, 1).Font.Bold = True
    resultRow = resultRow + 1

    ' Заголовки
    wsResult.Cells(resultRow, 1).Value = "Генератор"
    wsResult.Cells(resultRow, 2).Value = "Max Delta"
    wsResult.Cells(resultRow, 3).Value = "Min Delta"
    wsResult.Cells(resultRow, 4).Value = "Время Max Delta"
    wsResult.Cells(resultRow, 5).Value = "Нарушение устойчивости"
    wsResult.Cells(resultRow, 6).Value = "Время нарушения"
    wsResult.Range(wsResult.Cells(resultRow, 1), wsResult.Cells(resultRow, 6)).Font.Bold = True
    resultRow = resultRow + 1

    Dim scenarioBlockStart: scenarioBlockStart = resultRow
    
    ' Массивы для анализа ЭЦК
    Dim genCount: genCount = tblGen.Size
    ReDim deltaAtTime(genCount - 1)
    ReDim timeArray(genCount - 1)
    
    Dim dataCol: dataCol = 1
    Dim maxDeltaDiff: maxDeltaDiff = 0

    For i = 0 To genCount - 1
        genName = tblGen.Cols("Name").ZS(i)

        ' Получаем данные динамики
        Set Plot = Nothing
        For snapIdx = 5 To 0 Step -1
            On Error Resume Next
            tmpPlot = Rastr.GetChainedGraphSnapshot("Generator", "Delta", i, snapIdx)
            If Err.Number = 0 And IsArray(tmpPlot) Then
                Plot = tmpPlot
                Exit For
            End If
            On Error GoTo 0
        Next

        If IsArray(Plot) Then
            npoints = UBound(Plot, 1) + 1
            If npoints > 0 Then
                deltaCol = dataCol
                timeCol = dataCol + 1
                checkCol = dataCol + 2

                wsData.Cells(1, deltaCol).Value = genName & " (Delta)"
                wsData.Cells(1, timeCol).Value = genName & " (Time)"
                wsData.Cells(1, checkCol).Value = genName & " (>180)"

                wsData.Cells(2, deltaCol).Resize(npoints, 2).Value = Plot
                wsData.Cells(2, checkCol).Resize(npoints, 1).FormulaR1C1 = _
                    "=IF(RC" & deltaCol & ">180,ROW(),999999)"

                ' Сохраняем угол в момент TIME_WINDOW для анализа ЭЦК
                For p = 0 To npoints - 1
                    If Plot(p, 1) >= TIME_WINDOW Then
                        deltaAtTime(i) = Plot(p, 0)
                        timeArray(i) = Plot(p, 1)
                        Exit For
                    End If
                Next

                ' Формулы для таблицы результатов
                deltaRange = wsData.Cells(2, deltaCol).Address(False, False, 1, True) & ":" & _
                            wsData.Cells(npoints + 1, deltaCol).Address(False, False, 1, True)
                timeRange = wsData.Cells(2, timeCol).Address(False, False, 1, True) & ":" & _
                           wsData.Cells(npoints + 1, timeCol).Address(False, False, 1, True)
                checkRange = wsData.Cells(2, checkCol).Address(False, False, 1, True) & ":" & _
                            wsData.Cells(npoints + 1, checkCol).Address(False, False, 1, True)

                wsResult.Cells(resultRow, 1).Value = genName
                wsResult.Cells(resultRow, 2).Formula = "=MAX(" & deltaRange & ")"
                wsResult.Cells(resultRow, 3).Formula = "=MIN(" & deltaRange & ")"
                wsResult.Cells(resultRow, 4).Formula = _
                    "=INDEX(" & timeRange & ",MATCH(MAX(" & deltaRange & ")," & deltaRange & ",0))"
                wsResult.Cells(resultRow, 5).Formula = _
                    "=IF(MAX(" & deltaRange & ")>180,""нарушение устойчивости"",""нарушение устойчивости не выявлено"")"
                wsResult.Cells(resultRow, 6).Formula = _
                    "=IF(AND(MAX(" & deltaRange & ")>180,MIN(" & checkRange & ")<999999)," & _
                    "INDEX(" & timeRange & ",MATCH(MIN(" & checkRange & ")," & checkRange & ",0)),"""")"

                resultRow = resultRow + 1
                dataCol = dataCol + 3
            End If
        End If
    Next

    ' Фиксируем результаты
    Dim scenarioBlockEnd: scenarioBlockEnd = resultRow - 1
    If scenarioBlockEnd >= scenarioBlockStart Then
        xl.Calculate
        wsResult.Range(wsResult.Cells(scenarioBlockStart, 1), _
                      wsResult.Cells(scenarioBlockEnd, 6)).Value = _
            wsResult.Range(wsResult.Cells(scenarioBlockStart, 1), _
                          wsResult.Cells(scenarioBlockEnd, 6)).Value
    End If
    
    resultRow = resultRow + 1
    
    ' === АНАЛИЗ ЭЦК ===
    groups = ClusterGeneratorsByDelta(deltaAtTime, timeArray, TIME_WINDOW)
    Set groupsResult = FindECQLocation(groups, description)
    
    If Not groupsResult Is Nothing And UBound(groups) >= 1 Then
        ' Есть разделение на группы - ищем сечение
        Set cutSet = FindCutSetBetweenGroups(groups(0), groups(1))
        
        If cutSet.Count > 0 Then
            wsECQ.Cells(ecqRow, 1).Value = "Найдено связей между группами: " & cutSet.Count
            ecqRow = ecqRow + 1
            
            For Each brIdx In cutSet.Keys
                wsECQ.Cells(ecqRow, 1).Value = cutSet(brIdx)
                ecqRow = ecqRow + 1
            Next
            ecqRow = ecqRow + 1
            
            ' Ранжируем ветви для АЛАР
            Call RankBranchesForALAR(cutSet, groups)
        Else
            wsECQ.Cells(ecqRow, 1).Value = "Связи между группами не найдены (возможно, слабая связь через несколько узлов)"
            ecqRow = ecqRow + 2
        End If
    End If
End Sub

' ============================================================
' ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ (из исходного кода)
' ============================================================

Sub TopologyStore
    On Error Resume Next
    spNode.Cols.Add "staRes",PR_BOOL
    spBranch.Cols.Add "staRes",PR_BOOL
    On Error GoTo 0
    spNode.SetSel ""
    spNode.Cols("staRes").Calc("sta")
    spBranch.SetSel ""
    spBranch.Cols("staRes").Calc("sta")
End Sub

Sub TopologyRestore
    spNode.SetSel ""
    spNode.Cols("sta").Calc("staRes")
    spBranch.SetSel ""
    spBranch.Cols("sta").Calc("staRes")
End Sub

Function SolveUR()
    SolveUR = Rastr.rgm("p")
End Function

Sub PrepareTemplate
    If spBranch.Cols.Find("Repair") < 0 Then
        spBranch.Cols.Add "Repair", PR_BOOL
        spBranch.Cols("Repair").Prop(FL_ZAG) = "Ремонт"
    End If
    If spBranch.Cols.Find("Report") < 0 Then
        spBranch.Cols.Add "Report", PR_BOOL
        spBranch.Cols("Report").Prop(FL_ZAG) = "Отчет"
    End If
    If spBranch.Cols.Find("_SortKey") < 0 Then
        spBranch.Cols.Add "_SortKey", PR_INT
    End if
End Sub

Function PlaceOffs(byref V, OffCounter)
    OffList = ""
    Set colSta = spBranch.Cols("sta")
    Set colGrp = spBranch.Cols("groupid")
    Set colNm = spBranch.Cols("name")
    
    For offc = 0 To OffCounter-1
        If offc Then OffList = OffList + ","
        colSta.Z(V(offc)) = 1
        GroupId = colGrp.Z(V(offc))
        If GroupId > 0 Then
            spBranch.SetSel "groupid=" & CStr(GroupId)
            colSta.Calc 1
            spBranch.SetSel ""
        End If
        If OffList <> "" Then OffList = OffList + "|"
        OffList = OffList + CStr(colNm.ZS(V(offc)))
    Next
    PlaceOffs = OffList
End Function

' ============================================================
' ОСНОВНОЙ ЦИКЛ
' ============================================================

' Инициализация заголовков
wsALAR.Cells(1, 1).Value = "РЕКОМЕНДАЦИИ ПО УСТАНОВКЕ АЛАР"
wsALAR.Cells(1, 1).Font.Bold = True
wsALAR.Cells(1, 1).Font.Size = 14
alarRow = 3

wsECQ.Cells(1, 1).Value = "АНАЛИЗ ЭЛЕКТРИЧЕСКИХ ЦЕНТРОВ КАЧАНИЙ"
wsECQ.Cells(1, 1).Font.Bold = True
wsECQ.Cells(1, 1).Font.Size = 14
ecqRow = 3

' Загрузка сценария
Set fso = CreateObject("Scripting.FileSystemObject")

If fso.FileExists(ScenarioTemplatePath) Then
    Rastr.Load 1, ScenarioTemplatePath, ScenarioTemplatePath
    Set spFWDynamic = Rastr.FWDynamic
    
    If Not spFWDynamic Is Nothing Then
        TopologyStore
        
        ' Базовый расчет
        urRes = SolveUR()
        If urRes = 0 Then
            dynRes = spFWDynamic.Run()
            If dynRes = 0 Then
                Call RunDynamicsAndAnalyzeECQ("Нормальная схема", ScenarioTemplatePath)
            Else
                MsgBox "Ошибка расчета динамики: " & dynRes, vbCritical
            End If
        Else
            MsgBox "Ошибка расчета УР: " & urRes, vbCritical
        End If
    Else
        MsgBox "FWDynamic не инициализирован", vbCritical
    End If
Else
    MsgBox "Файл сценария не найден: " & ScenarioTemplatePath, vbCritical
End If

' Автоподгонка колонок
wsResult.Columns.AutoFit
wsECQ.Columns.AutoFit
wsALAR.Columns.AutoFit

MsgBox "Анализ завершен. Проверьте листы 'Анализ ЭЦК' и 'Рекомендации АЛАР'", vbInformation

xl.DisplayAlerts = True
