' --- Определение критического времени отключения КЗ ---
' Скрипт для определения критического времени отключения КЗ
' при изменении мощности выбранных генераторов от 60% до 100%

' --- Инициализация Excel ---
Set xl = CreateObject("Excel.Application")
xl.Visible = True
xl.DisplayAlerts = False
Set wb = xl.Workbooks.Add
Set wsData = wb.Worksheets(1)
wsData.Name = "Данные"
Set wsResult = wb.Worksheets.Add
wsResult.Name = "Результаты"
Set wsLog = wb.Worksheets.Add
wsLog.Name = "Логи"

Dim resultRow: resultRow = 1

' --- Rastr таблицы ---
Set spBranch = Rastr.Tables("vetv")
Set spNode   = Rastr.Tables("node")
Set tblGen   = Rastr.Tables("Generator")

If tblGen Is Nothing Then
    MsgBox "Ошибка: Таблица Generator не найдена!", vbCritical, "Ошибка"
    WScript.Quit
End If

' --- Получение колонок ---
Set colGenName = tblGen.Cols("Name")
Set colGenNy   = tblGen.Cols("Node")
Set colGenSel  = tblGen.Cols("sel")
Set colGenP    = tblGen.Cols("P") ' Текущая мощность генератора
Set colGenPnom = tblGen.Cols("Pnom") ' Номинальная мощность генератора (100%)

If colGenName Is Nothing Or colGenNy Is Nothing Or colGenP Is Nothing Then
    MsgBox "Ошибка: Не найдены необходимые колонки в таблице Generator (Name/Node/P)!", vbCritical, "Ошибка"
    WScript.Quit
End If

' Проверка наличия поля sel для выбора генераторов
On Error Resume Next
Set colGenSel = tblGen.Cols("sel")
If Err.Number <> 0 Then
    ' Создаем поле sel, если его нет
    tblGen.Cols.Add "sel", PR_BOOL
    tblGen.Cols("sel").Prop(FL_ZAG) = "Выбор"
    Set colGenSel = tblGen.Cols("sel")
    MsgBox "Добавлено поле sel в таблицу Generator. Выберите генераторы и запустите скрипт повторно.", vbInformation, "Подготовка"
    WScript.Quit
End If
On Error GoTo 0

' Получение колонок узлов
Set spNodeNy   = spNode.Cols("ny")
Set spNodePg   = spNode.Cols("pg")  ' Генерация в узле

If spNodePg Is Nothing Then
    MsgBox "Ошибка: Не найдена колонка генерации в таблице node (pg)!", vbCritical, "Ошибка"
    WScript.Quit
End If

' --- Логирование в Excel ---
Dim logRow: logRow = 1
Sub LogBinaryStep(powerLevel, phase, iteration, tMin, tMid, tMax, maxDelta, statusText, dynCode, snapIdx)
    wsLog.Cells(logRow, 1).Value = powerLevel
    wsLog.Cells(logRow, 2).Value = phase
    wsLog.Cells(logRow, 3).Value = iteration
    wsLog.Cells(logRow, 4).Value = tMin
    wsLog.Cells(logRow, 5).Value = tMid
    wsLog.Cells(logRow, 6).Value = tMax
    wsLog.Cells(logRow, 7).Value = maxDelta
    wsLog.Cells(logRow, 8).Value = statusText
    wsLog.Cells(logRow, 9).Value = dynCode
    wsLog.Cells(logRow, 10).Value = snapIdx
    logRow = logRow + 1
End Sub

' --- Получение FWDynamic ---
Set spFWDynamic = Rastr.FWDynamic
If spFWDynamic Is Nothing Then
    MsgBox "Ошибка: FWDynamic недоступен! Убедитесь, что сценарий загружен.", vbCritical, "Ошибка"
    WScript.Quit
End If

' Глобальная переменная для последнего snapIdx
Dim lastSnapIdx: lastSnapIdx = -1

' Сохраняем исходное время отключения КЗ (если доступно)
Dim originalTimeClear: originalTimeClear = -1
On Error Resume Next
originalTimeClear = spFWDynamic.TimeClear
On Error GoTo 0

' --- Функция пересчёта установившегося режима ---
Function SolveUR()
    SolveUR = Rastr.rgm("p")
End Function

' --- Функция получения MaxDelta и проверки устойчивости ---
Function GetMaxDelta()
    Dim maxDelta: maxDelta = 0
    lastSnapIdx = -1

    ' Очищаем wsData
    wsData.Cells.Clear

    Dim dataCol: dataCol = 1

    For i = 0 To tblGen.Size - 1
        Plot = Empty
        npoints = 0

        ' Пробуем snapIdx от 5 до 0
        For snapIdx = 5 To 0 Step -1
            On Error Resume Next
            Plot = Rastr.GetChainedGraphSnapshot("Generator", "Delta", i, snapIdx)
            errNum = Err.Number
            If errNum = 0 And IsArray(Plot) Then
                npoints = UBound(Plot, 1) + 1
                If npoints > 0 Then
                    lastSnapIdx = snapIdx
                    Exit For
                End If
            End If
            On Error GoTo 0
        Next

        If errNum = 0 And IsArray(Plot) And npoints > 0 Then
            ' Записываем Plot в wsData
            wsData.Cells(2, dataCol).Resize(npoints, 2).Value = Plot

            ' Диапазон для Delta
            deltaStartAddr = wsData.Cells(2, dataCol).Address(False, False, 1, True)
            deltaEndAddr = wsData.Cells(npoints + 1, dataCol).Address(False, False, 1, True)
            deltaRange = deltaStartAddr & ":" & deltaEndAddr

            ' Формула MAX
            wsData.Cells(2, dataCol + 2).Formula = "=MAX(" & deltaRange & ")"

            ' Рассчитываем
            xl.Calculate

            ' Получаем max для этого генератора
            maxGen = Abs(wsData.Cells(2, dataCol + 2).Value)
            If maxGen > maxDelta Then
                maxDelta = maxGen
            End If

            dataCol = dataCol + 3
        End If
    Next

    GetMaxDelta = maxDelta
End Function

Function CheckStabilityViolation()
    CheckStabilityViolation = (GetMaxDelta() > 180)
End Function

' MaxDelta для конкретного генератора
Function GetGenMaxDelta(genIndex)
    Dim maxDelta: maxDelta = 0
    Plot = Empty
    npoints = 0

    ' Очищаем wsData
    wsData.Cells.Clear

    ' Пробуем snapIdx от 5 до 0
    For snapIdx = 5 To 0 Step -1
        On Error Resume Next
        Plot = Rastr.GetChainedGraphSnapshot("Generator", "Delta", genIndex, snapIdx)
        errNum = Err.Number
        If errNum = 0 And IsArray(Plot) Then
            npoints = UBound(Plot, 1) + 1
            If npoints > 0 Then
                Exit For
            End If
        End If
        On Error GoTo 0
    Next

    If errNum = 0 And IsArray(Plot) And npoints > 0 Then
        ' Записываем Plot в wsData
        wsData.Cells(2, 1).Resize(npoints, 2).Value = Plot

        ' Диапазон для Delta
        deltaStartAddr = wsData.Cells(2, 1).Address(False, False, 1, True)
        deltaEndAddr = wsData.Cells(npoints + 1, 1).Address(False, False, 1, True)
        deltaRange = deltaStartAddr & ":" & deltaEndAddr

        ' Формула MAX
        wsData.Cells(2, 3).Formula = "=MAX(" & deltaRange & ")"

        ' Рассчитываем
        xl.Calculate

        ' Получаем max
        maxDelta = Abs(wsData.Cells(2, 3).Value)
    End If

    GetGenMaxDelta = maxDelta
End Function

' --- Функция установки длительности действия "Шунт Z" ---
Sub SetShuntDuration(tClear)
    On Error Resume Next

    Set tblEvents = Rastr.Tables("DFWAutoActionScn")

    If Not tblEvents Is Nothing Then
        Set colType = tblEvents.Cols("Type")
        Set colName = tblEvents.Cols("Name")
        Set colDT = tblEvents.Cols("DT")

        If Not colType Is Nothing And Not colDT Is Nothing Then
            ' Ищем действие типа "Объект" с названием, содержащим "Шунт Z"
            For i = 0 To tblEvents.Size - 1
                If colType.ZS(i) = "Объект" And InStr(colName.ZS(i), "Шунт Z") > 0 Then
                    ' Устанавливаем длительность в мс
                    colDT.Z(i) = tClear
                    Exit For
                End If
            Next
        End If
    End If

    On Error GoTo 0
End Sub

' --- Функция двоичного поиска критического времени отключения КЗ ---
Function BinarySearchCriticalTime(powerLevel, baseGenValues, selectedGenIndices)
    ' Параметры двоичного поиска
    Dim tMin: tMin = 0.0
    Dim tMax: tMax = 1000.0
    Dim epsilon: epsilon = 10.0
    Dim tCritical: tCritical = -1
    Dim maxIterations: maxIterations = 50
    Dim iteration: iteration = 0

    ' Восстанавливаем мощность генераторов
    For idx = 0 To UBound(selectedGenIndices)
        genIdx = selectedGenIndices(idx)
        colGenP.Z(genIdx) = baseGenValues(idx) * powerLevel / 100.0
    Next

    If SolveUR() <> 0 Then
        BinarySearchCriticalTime = -1
        Exit Function
    End If

    ' Проверка при tMin (короткая длительность шунта - должно быть УСТОЙЧИВО)
    Call SetShuntDuration(tMin)
    dynRes = spFWDynamic.Run()
    If dynRes <> 0 Then
        BinarySearchCriticalTime = -1
        Exit Function
    End If

    Dim maxDelta: maxDelta = GetMaxDelta()
    Dim stableAtMin: stableAtMin = (maxDelta <= 180)
    Dim statusMin
    If stableAtMin Then
        statusMin = "устойчив"
    Else
        statusMin = "нарушен"
    End If
    Call LogBinaryStep(powerLevel, "start_min", "", tMin, "", tMax, maxDelta, statusMin, dynRes, lastSnapIdx)

    ' Если при минимальном времени система неустойчива - что-то не так
    If Not stableAtMin Then
        BinarySearchCriticalTime = tMin
        Exit Function
    End If

    ' Проверка при tMax (длинная длительность шунта - должно быть НЕУСТОЙЧИВО)
    For idx = 0 To UBound(selectedGenIndices)
        genIdx = selectedGenIndices(idx)
        colGenP.Z(genIdx) = baseGenValues(idx) * powerLevel / 100.0
    Next
    If SolveUR() <> 0 Then
        BinarySearchCriticalTime = -1
        Exit Function
    End If

    Call SetShuntDuration(tMax)
    dynRes = spFWDynamic.Run()
    If dynRes <> 0 Then
        BinarySearchCriticalTime = -1
        Exit Function
    End If

    maxDelta = GetMaxDelta()
    Dim unstableAtMax: unstableAtMax = (maxDelta > 180)
    Dim statusMax
    If unstableAtMax Then
        statusMax = "нарушен"
    Else
        statusMax = "устойчив"
    End If
    Call LogBinaryStep(powerLevel, "start_max", "", tMin, "", tMax, maxDelta, statusMax, dynRes, lastSnapIdx)

    ' Если при максимальном времени всё ещё устойчивость
    If Not unstableAtMax Then
        BinarySearchCriticalTime = tMax  ' Возвращаем максимум как "не найдено"
        Exit Function
    End If

    ' ДВОИЧНЫЙ ПОИСК: ищем максимальное время, при котором ещё устойчиво
    Do While (tMax - tMin) > epsilon And iteration < maxIterations
        iteration = iteration + 1
        tMid = (tMin + tMax) / 2.0

        ' ВАЖНО: Восстанавливаем мощности перед каждым расчётом
        For idx = 0 To UBound(selectedGenIndices)
            genIdx = selectedGenIndices(idx)
            colGenP.Z(genIdx) = baseGenValues(idx) * powerLevel / 100.0
        Next

        If SolveUR() <> 0 Then
            BinarySearchCriticalTime = -1
            Exit Function
        End If

        Call SetShuntDuration(tMid)

        dynRes = spFWDynamic.Run()
        If dynRes <> 0 Then
            BinarySearchCriticalTime = -1
            Exit Function
        End If

        maxDelta = GetMaxDelta()
        Dim stableNow: stableNow = (maxDelta <= 180)
        Dim statusNow
        If stableNow Then
            statusNow = "устойчив"
        Else
            statusNow = "нарушен"
        End If
        Call LogBinaryStep(powerLevel, "binary", iteration, tMin, tMid, tMax, maxDelta, statusNow, dynRes, lastSnapIdx)

        ' ИСПРАВЛЕННАЯ ЛОГИКА для длительности шунта:
        If stableNow Then
            ' Устойчиво - можем попробовать большее время (двигаем нижнюю границу)
            tMin = tMid
        Else
            ' Неустойчиво - нужно меньшее время (двигаем верхнюю границу)
            tMax = tMid
        End If
    Loop

    ' Критическое время - это tMin (максимальное время, при котором ещё устойчиво)
    BinarySearchCriticalTime = tMin
End Function

' --- Основная логика ---

' 1. Получаем список выбранных генераторов и базовую мощность
Dim selectedGenIndices()
Dim selectedNodeIndices()
Dim originalGenValues()
Dim basePgValues()
ReDim selectedGenIndices(-1)
ReDim selectedNodeIndices(-1)
ReDim originalGenValues(-1)
ReDim basePgValues(-1)

tblGen.SetSel("sel")
genIdx = tblGen.FindNextSel(-1)
While genIdx >= 0
    ReDim Preserve selectedGenIndices(UBound(selectedGenIndices) + 1)
    selectedGenIndices(UBound(selectedGenIndices)) = genIdx
    
    ' Получаем номер узла генератора
    nodeNum = colGenNy.Z(genIdx)
    
    ' Находим индекс узла по номеру
    nodeIdx = -1
    For i = 0 To spNode.Size - 1
        If spNodeNy.Z(i) = nodeNum Then
            nodeIdx = i
            Exit For
        End If
    Next
    
    If nodeIdx >= 0 Then
        ReDim Preserve selectedNodeIndices(UBound(selectedNodeIndices) + 1)
        selectedNodeIndices(UBound(selectedNodeIndices)) = nodeIdx
        
        ' Сохраняем исходное значение текущей мощности генератора
        ReDim Preserve originalGenValues(UBound(originalGenValues) + 1)
        originalGenValues(UBound(originalGenValues)) = colGenP.Z(genIdx)

        ' Базовая мощность: из Generator.Pnom (100%). Если пусто/не число, берём текущий P генератора.
        ReDim Preserve basePgValues(UBound(basePgValues) + 1)
        Dim pVal
        pVal = colGenPnom.Z(genIdx)
        If IsNumeric(pVal) And Not IsNull(pVal) Then
            basePgValues(UBound(basePgValues)) = CDbl(pVal)
        Else
            basePgValues(UBound(basePgValues)) = colGenP.Z(genIdx)
        End If
    End If
    
    genIdx = tblGen.FindNextSel(genIdx)
Wend

If UBound(selectedGenIndices) < 0 Then
    MsgBox "Не выбрано ни одного генератора! Отметьте генераторы в поле sel и запустите скрипт повторно.", vbExclamation, "Нет выбора"
    WScript.Quit
End If

' 2. Заголовок таблицы результатов
wsResult.Cells(resultRow, 1).Value = "Уровень мощности (%)"
wsResult.Cells(resultRow, 2).Value = "Генератор"
wsResult.Cells(resultRow, 3).Value = "Max Delta"
wsResult.Cells(resultRow, 4).Value = "Статус"
wsResult.Cells(resultRow, 5).Value = "Критическое время отключения КЗ (мс)"
wsResult.Range(wsResult.Cells(resultRow, 1), wsResult.Cells(resultRow, 5)).Font.Bold = True
resultRow = resultRow + 1

' Заголовок логов
wsLog.Cells(1, 1).Value = "Мощность %"
wsLog.Cells(1, 2).Value = "Фаза"
wsLog.Cells(1, 3).Value = "Итерация"
wsLog.Cells(1, 4).Value = "t_min"
wsLog.Cells(1, 5).Value = "t_mid"
wsLog.Cells(1, 6).Value = "t_max"
wsLog.Cells(1, 7).Value = "MaxDelta"
wsLog.Cells(1, 8).Value = "Статус"
wsLog.Cells(1, 9).Value = "DynCode"
wsLog.Cells(1, 10).Value = "SnapIdx"
wsLog.Rows(1).Font.Bold = True
logRow = 2

' 3. Цикл по уровням мощности (60%, 70%, 80%, 90%, 100%)
Dim powerLevels(4)
powerLevels(0) = 60
powerLevels(1) = 70
powerLevels(2) = 80
powerLevels(3) = 90
powerLevels(4) = 100

' ИСПРАВЛЕНИЕ: объявляем переменные ДО цикла
Dim tCriticalForRows
Dim genMaxDeltas()
Dim anyViolation
Dim tCritical
Dim g, genIdx, genName
Dim maxDelta, stableNow, statusBase

For pIdx = 0 To UBound(powerLevels)
    powerLevel = powerLevels(pIdx)
    
    ' Устанавливаем мощность генераторов для текущего уровня мощности
    For idx = 0 To UBound(selectedGenIndices)
        genIdx = selectedGenIndices(idx)
        colGenP.Z(genIdx) = basePgValues(idx) * powerLevel / 100.0
    Next
    
    ' Сбрасываем значение для текущей итерации
    tCriticalForRows = ""
    
    ' Пересчитываем установившийся режим
    urRes = SolveUR()
    If urRes = 0 Then
        ' Запускаем динамику с исходным временем отключения КЗ
        dynRes = spFWDynamic.Run()
        If dynRes = 0 Then
            ' Пер-генераторные MaxDelta - пересоздаём массив для текущей итерации
            ReDim genMaxDeltas(UBound(selectedGenIndices))
            anyViolation = False
            For g = 0 To UBound(selectedGenIndices)
                genIdx = selectedGenIndices(g)
                genMaxDeltas(g) = GetGenMaxDelta(genIdx)
                If genMaxDeltas(g) > 180 Then anyViolation = True
            Next
            
            ' Системный максимум для лога/бинарного поиска
            maxDelta = GetMaxDelta()
            stableNow = (maxDelta <= 180)
            statusBase = ""
            If stableNow Then
                statusBase = "устойчив"
            Else
                statusBase = "нарушен"
            End If
            Call LogBinaryStep(powerLevel, "base", "", "", "", "", maxDelta, statusBase, dynRes, lastSnapIdx)
            
            If anyViolation Then
                ' Нарушение устойчивости - используем двоичный поиск (по системе)
                tCritical = BinarySearchCriticalTime(powerLevel, basePgValues, selectedGenIndices)
                If IsNumeric(tCritical) And tCritical >= 0 Then
                    ' ИСПРАВЛЕНИЕ: безопасное преобразование
                    tCriticalForRows = FormatNumber(CDbl(tCritical), 3)
                Else
                    tCriticalForRows = "Ошибка поиска"
                End If
            Else
                tCriticalForRows = "> 1000.0"
            End If
            
            ' Записываем по каждому генератору
            For g = 0 To UBound(selectedGenIndices)
                genIdx = selectedGenIndices(g)
                genName = colGenName.ZS(genIdx)
                wsResult.Cells(resultRow, 1).Value = powerLevel & "%"
                wsResult.Cells(resultRow, 2).Value = genName
                wsResult.Cells(resultRow, 3).Value = FormatNumber(genMaxDeltas(g), 3)
                If genMaxDeltas(g) > 180 Then
                    wsResult.Cells(resultRow, 4).Value = "Нарушение устойчивости"
                Else
                    wsResult.Cells(resultRow, 4).Value = "Устойчивость сохранена"
                End If
                wsResult.Cells(resultRow, 5).Value = tCriticalForRows
                resultRow = resultRow + 1
            Next
        Else
            wsResult.Cells(resultRow, 1).Value = powerLevel & "%"
            wsResult.Cells(resultRow, 2).Value = ""
            wsResult.Cells(resultRow, 3).Value = ""
            wsResult.Cells(resultRow, 4).Value = "Ошибка расчёта динамики"
            wsResult.Cells(resultRow, 5).Value = "Ошибка (код " & dynRes & ")"
            Call LogBinaryStep(powerLevel, "base_dyn_err", "", "", "", "", "", CStr("dyn_err"), dynRes, -1)
            resultRow = resultRow + 1
        End If
    Else
        wsResult.Cells(resultRow, 1).Value = powerLevel & "%"
        wsResult.Cells(resultRow, 2).Value = ""
        wsResult.Cells(resultRow, 3).Value = ""
        wsResult.Cells(resultRow, 4).Value = "Ошибка расчёта УР"
        wsResult.Cells(resultRow, 5).Value = "Ошибка (код " & urRes & ")"
        Call LogBinaryStep(powerLevel, "base_ur_err", "", "", "", "", "", CStr("ur_err"), urRes, -1)
        resultRow = resultRow + 1
    End If
Next
